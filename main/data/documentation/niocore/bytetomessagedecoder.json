{"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"]]},"kind":"symbol","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/niocore\/bytetomessagedecoder"]}],"schemaVersion":{"minor":3,"patch":0,"major":0},"sections":[],"identifier":{"url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder","interfaceLanguage":"swift"},"relationshipsSections":[{"kind":"relationships","title":"Inherited By","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteObservingByteToMessageDecoder"],"type":"inheritedBy"},{"kind":"relationships","title":"Conforming Types","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/FixedLengthFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LineBasedFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/SNIHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOWebSocket\/WebSocketFrameDecoder"],"type":"conformingTypes"}],"topicSections":[{"title":"Associated Types","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/InboundOut"]},{"title":"Instance Methods","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decode(context:buffer:)","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-1tkzf","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderAdded(context:)-7trzq","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderRemoved(context:)-sa8l","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5fn2u","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/wrapInboundOut(_:)"]}],"primaryContentSections":[{"declarations":[{"tokens":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"ByteToMessageDecoder"}],"platforms":["Linux"],"languages":["swift"]}],"kind":"declarations"},{"kind":"content","content":[{"type":"heading","anchor":"Purpose","text":"Purpose","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" provides a simplified API for handling streams of incoming data that can be broken"},{"type":"text","text":" "},{"type":"text","text":"up into messages. This API boils down to two methods: "},{"type":"codeVoice","code":"decode"},{"type":"text","text":", and "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":". These two methods, when"},{"type":"text","text":" "},{"type":"text","text":"implemented, will be used by a "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":" paired with a "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" to decode the"},{"type":"text","text":" "},{"type":"text","text":"incoming byte stream into a sequence of messages."}]},{"type":"paragraph","inlineContent":[{"text":"The reason this helper exists is to smooth away some of the boilerplate and edge case handling code that","type":"text"},{"text":" ","type":"text"},{"text":"is often necessary when implementing parsers in a SwiftNIO ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":". A ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" ","type":"text"},{"text":"never needs to worry about how inbound bytes will be buffered, as ","type":"text"},{"code":"ByteToMessageHandler","type":"codeVoice"},{"text":" deals with that","type":"text"},{"text":" ","type":"text"},{"text":"automatically. A ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" also never needs to worry about memory exclusivity violations","type":"text"},{"text":" ","type":"text"},{"text":"that can occur when re-entrant ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" operations occur, as ","type":"text"},{"code":"ByteToMessageHandler","type":"codeVoice"},{"text":" will deal with","type":"text"},{"text":" ","type":"text"},{"text":"those as well.","type":"text"}]},{"type":"heading","anchor":"Implementing-ByteToMessageDecoder","text":"Implementing ByteToMessageDecoder","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"A type that implements "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" may implement two methods: decode and decodeLast. Implementations"},{"type":"text","text":" "},{"type":"text","text":"must implement decode: if they do not implement decodeLast, a default implementation will be used that"},{"type":"text","text":" "},{"type":"text","text":"simply calls decode."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"decode"},{"type":"text","text":" is the main decoding method, and is the one that will be called most often. "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" is invoked"},{"type":"text","text":" "},{"type":"text","text":"whenever data is received by the wrapping "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":". It is invoked with a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" containing"},{"type":"text","text":" "},{"type":"text","text":"all the received data (including any data previously buffered), as well as a "},{"type":"codeVoice","code":"ChannelHandlerContext"},{"type":"text","text":" that can be"},{"type":"text","text":" "},{"type":"text","text":"used in the "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" function."}]},{"type":"paragraph","inlineContent":[{"code":"decode","type":"codeVoice"},{"type":"text","text":" is called in a loop by the "},{"code":"ByteToMessageHandler","type":"codeVoice"},{"type":"text","text":". This loop continues until one of two cases occurs:"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"The input "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" has no more readable bytes (i.e. "},{"code":".readableBytes == 0","type":"codeVoice"},{"type":"text","text":"); OR"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" method returns "},{"type":"codeVoice","code":".needMoreData"},{"type":"text","text":"."}]}]}]},{"type":"paragraph","inlineContent":[{"text":"The reason this method is invoked in a loop is to ensure that the stream-like properties of inbound data are","type":"text"},{"text":" ","type":"text"},{"text":"respected. It is entirely possible for ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" to receive either fewer bytes than a single message,","type":"text"},{"text":" ","type":"text"},{"text":"or multiple messages in one go. Rather than have the ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" handle all of the complexity of this,","type":"text"},{"text":" ","type":"text"},{"text":"the logic can be boiled down to a single choice: has the ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" been able to move the state forward","type":"text"},{"text":" ","type":"text"},{"text":"or not? If it has, rather than containing an internal loop it may simply return ","type":"text"},{"type":"codeVoice","code":".continue"},{"text":" in order to request that","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":" be invoked again immediately. If it has not, it can return ","type":"text"},{"type":"codeVoice","code":".needMoreData"},{"text":" to ask to be left alone until more","type":"text"},{"text":" ","type":"text"},{"text":"data has been returned from the network.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Essentially, if the next parsing step could not be taken because there wasn’t enough data available, return "},{"code":".needMoreData","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Otherwise, return "},{"code":".continue","type":"codeVoice"},{"type":"text","text":". This will allow a "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" implementation to ignore the awkward way data"},{"type":"text","text":" "},{"type":"text","text":"arrives from the network, and to just treat it as a series of "},{"code":"decode","type":"codeVoice"},{"type":"text","text":" calls."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" is a cousin of "},{"type":"codeVoice","code":"decode"},{"type":"text","text":". It is also called in a loop, but unlike with "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" this loop will only ever"},{"type":"text","text":" "},{"type":"text","text":"occur once: when the "},{"type":"codeVoice","code":"ChannelHandlerContext"},{"type":"text","text":" belonging to this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is about to become invalidated."},{"type":"text","text":" "},{"type":"text","text":"This invalidation happens in two situations: when EOF is received from the network, or when the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" "},{"type":"text","text":"is being removed from the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":". The distinction between these two states is captured by the value of"},{"type":"text","text":" "},{"type":"codeVoice","code":"seenEOF"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"In this condition, the ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" must now produce any final messages it can with the bytes it has","type":"text"},{"text":" ","type":"text"},{"text":"available. In protocols where EOF is used as a message delimiter, having ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" called with ","type":"text"},{"code":"seenEOF == true","type":"codeVoice"},{"text":" ","type":"text"},{"text":"may produce further messages. In other cases, ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" may choose to deliver any buffered bytes as “leftovers”,","type":"text"},{"text":" ","type":"text"},{"text":"either in error messages or via ","type":"text"},{"code":"channelRead","type":"codeVoice"},{"text":". This can occur if, for example, a protocol upgrade is occurring.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As with "},{"code":"decode","type":"codeVoice"},{"type":"text","text":", "},{"code":"decodeLast","type":"codeVoice"},{"type":"text","text":" is invoked in a loop. This allows the same simplification as "},{"code":"decode","type":"codeVoice"},{"type":"text","text":" allows: when"},{"type":"text","text":" "},{"type":"text","text":"a message is completely parsed, the "},{"code":"decodeLast","type":"codeVoice"},{"type":"text","text":" function can return "},{"code":".continue","type":"codeVoice"},{"type":"text","text":" and be re-invoked from the top,"},{"type":"text","text":" "},{"type":"text","text":"rather than containing an internal loop."}]},{"type":"paragraph","inlineContent":[{"text":"Note that the value of ","type":"text"},{"code":"seenEOF","type":"codeVoice"},{"text":" may change between calls to ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" in some rare situations.","type":"text"}]},{"type":"heading","anchor":"Implementers-Notes","text":"Implementers Notes","level":3},{"type":"paragraph","inlineContent":[{"text":"\/\/\/ ","type":"text"},{"type":"codeVoice","code":"ByteToMessageHandler"},{"text":" will turn your ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" into a ","type":"text"},{"type":"codeVoice","code":"ChannelInboundHandler"},{"text":". ","type":"text"},{"type":"codeVoice","code":"ByteToMessageHandler"},{"text":" ","type":"text"},{"text":"also solves a couple of tricky issues for you. Most importantly, in a ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" you do ","type":"text"},{"inlineContent":[{"type":"text","text":"not"}],"type":"emphasis"},{"text":" need to","type":"text"},{"text":" ","type":"text"},{"text":"worry about re-entrancy. Your code owns the passed-in ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" for the duration of the ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":"\/","type":"text"},{"type":"codeVoice","code":"decodeLast"},{"text":" call and","type":"text"},{"text":" ","type":"text"},{"text":"can modify it at will.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a custom frame decoder is required, then one needs to be careful when implementing"},{"type":"text","text":" "},{"type":"text","text":"one with "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":". Ensure there are enough bytes in the buffer for a"},{"type":"text","text":" "},{"type":"text","text":"complete frame by checking "},{"type":"codeVoice","code":"buffer.readableBytes"},{"type":"text","text":". If there are not enough bytes"},{"type":"text","text":" "},{"type":"text","text":"for a complete frame, return without modifying the reader index to allow more bytes to arrive."}]},{"type":"paragraph","inlineContent":[{"text":"To check for complete frames without modifying the reader index, use methods like ","type":"text"},{"code":"buffer.getInteger","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"You  ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"MUST"}]},{"text":" use the reader index when using methods like ","type":"text"},{"code":"buffer.getInteger","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"For example calling ","type":"text"},{"code":"buffer.getInteger(at: 0)","type":"codeVoice"},{"text":" is assuming the frame starts at the beginning of the buffer, which","type":"text"},{"text":" ","type":"text"},{"text":"is not always the case. Use ","type":"text"},{"code":"buffer.getInteger(at: buffer.readerIndex)","type":"codeVoice"},{"text":" instead.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"If you move the reader index forward, either manually or by using one of ","type":"text"},{"type":"codeVoice","code":"buffer.read*"},{"text":" methods, you must ensure","type":"text"},{"text":" ","type":"text"},{"text":"that you no longer need to see those bytes again as they will not be returned to you the next time ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":" is","type":"text"},{"text":" ","type":"text"},{"text":"called. If you still need those bytes to come back, consider taking a local copy of buffer inside the function to","type":"text"},{"text":" ","type":"text"},{"text":"perform your read operations on.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" passed in as ","type":"text"},{"type":"codeVoice","code":"buffer"},{"text":" is a slice of a larger buffer owned by the ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" ","type":"text"},{"text":"implementation. Some aspects of this buffer are preserved across calls to ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":", meaning that any changes to","type":"text"},{"text":" ","type":"text"},{"text":"those properties you make in your ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":" method will be reflected in the next call to decode. In particular,","type":"text"},{"text":" ","type":"text"},{"text":"moving the reader index forward persists across calls. When your method returns, if the reader index has advanced,","type":"text"},{"text":" ","type":"text"},{"text":"those bytes are considered “consumed” and will not be available in future calls to ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Please note, however, that the numerical value of the ","type":"text"},{"type":"codeVoice","code":"readerIndex"},{"text":" itself is not preserved, and may not be the same","type":"text"},{"text":" ","type":"text"},{"text":"from one call to the next. Please do not rely on this numerical value: if you need","type":"text"},{"text":" ","type":"text"},{"text":"to recall where a byte is relative to the ","type":"text"},{"type":"codeVoice","code":"readerIndex"},{"text":", use an offset rather than an absolute value.","type":"text"}]},{"type":"heading","anchor":"Using-ByteToMessageDecoder","text":"Using ByteToMessageDecoder","level":3},{"type":"paragraph","inlineContent":[{"text":"To add a ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" to the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" use","type":"text"}]},{"code":["channel.pipeline.addHandler(ByteToMessageHandler(MyByteToMessageDecoder()))"],"type":"codeListing","syntax":null}]}],"abstract":[{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":"s decode bytes in a stream-like fashion from ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" to another message type.","type":"text"}],"metadata":{"modules":[{"name":"NIOCore"}],"externalID":"s:7NIOCore20ByteToMessageDecoderP","role":"symbol","navigatorTitle":[{"text":"ByteToMessageDecoder","kind":"identifier"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageDecoder","kind":"identifier"}],"roleHeading":"Protocol","symbolKind":"protocol","title":"ByteToMessageDecoder"},"references":{"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/wrapInboundOut(_:)":{"fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"wrapInboundOut","kind":"identifier"},{"text":"(","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"InboundOut","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"NIOAny","preciseIdentifier":"s:7NIOCore6NIOAnyV","kind":"typeIdentifier"}],"role":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/wrapInboundOut(_:)","title":"wrapInboundOut(_:)","kind":"symbol","abstract":[],"url":"\/documentation\/niocore\/bytetomessagedecoder\/wrapinboundout(_:)"},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"kind":"symbol","url":"\/documentation\/niocore","title":"NIOCore","role":"collection","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","abstract":[]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LineBasedFrameDecoder":{"abstract":[{"type":"text","text":"A decoder that splits incoming "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":"s around line end"},{"type":"text","text":" "},{"type":"text","text":"character(s) ("},{"type":"codeVoice","code":"'\\n'"},{"type":"text","text":" or "},{"type":"codeVoice","code":"'\\r\\n'"},{"type":"text","text":")."}],"kind":"symbol","url":"\/documentation\/nioextras\/linebasedframedecoder","navigatorTitle":[{"text":"LineBasedFrameDecoder","kind":"identifier"}],"type":"topic","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LineBasedFrameDecoder","title":"LineBasedFrameDecoder","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LineBasedFrameDecoder","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/FixedLengthFrameDecoder":{"kind":"symbol","url":"\/documentation\/nioextras\/fixedlengthframedecoder","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"FixedLengthFrameDecoder"}],"type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"FixedLengthFrameDecoder"}],"abstract":[{"text":"A decoder that splits the received ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" by a fixed number","type":"text"},{"text":" ","type":"text"},{"text":"of bytes. For example, if you received the following four fragmented packets:","type":"text"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/FixedLengthFrameDecoder","title":"FixedLengthFrameDecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder":{"navigatorTitle":[{"text":"ByteToMessageDecoder","kind":"identifier"}],"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder","title":"ByteToMessageDecoder","abstract":[{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"s decode bytes in a stream-like fashion from "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" to another message type."}],"type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"ByteToMessageDecoder","kind":"identifier"}],"url":"\/documentation\/niocore\/bytetomessagedecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/shouldReclaimBytes(buffer:)-5fn2u":{"required":true,"abstract":[{"type":"text","text":"Determine if the read bytes in the given "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" should be reclaimed and their associated memory freed."},{"type":"text","text":" "},{"type":"text","text":"Be aware that reclaiming memory may involve memory copies and so is not free."}],"title":"shouldReclaimBytes(buffer:)","url":"\/documentation\/niocore\/bytetomessagedecoder\/shouldreclaimbytes(buffer:)-5fn2u","role":"symbol","kind":"symbol","defaultImplementations":1,"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5fn2u","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"shouldReclaimBytes"},{"kind":"text","text":"("},{"kind":"externalParam","text":"buffer"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7NIOCore10ByteBufferV","kind":"typeIdentifier","text":"ByteBuffer"},{"kind":"text","text":") -> "},{"preciseIdentifier":"s:Sb","kind":"typeIdentifier","text":"Bool"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/WriteObservingByteToMessageDecoder":{"abstract":[{"type":"text","text":"Some "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"s need to observe "},{"type":"codeVoice","code":"write"},{"type":"text","text":"s (which are outbound events). "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"s which"},{"text":" ","type":"text"},{"text":"implement the ","type":"text"},{"code":"WriteObservingByteToMessageDecoder","type":"codeVoice"},{"text":" protocol will be notified about every outbound write.","type":"text"}],"type":"topic","kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"WriteObservingByteToMessageDecoder"}],"navigatorTitle":[{"kind":"identifier","text":"WriteObservingByteToMessageDecoder"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteObservingByteToMessageDecoder","title":"WriteObservingByteToMessageDecoder","url":"\/documentation\/niocore\/writeobservingbytetomessagedecoder","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOSingleStepByteToMessageDecoder":{"title":"NIOSingleStepByteToMessageDecoder","url":"\/documentation\/niocore\/niosinglestepbytetomessagedecoder","kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSingleStepByteToMessageDecoder"}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOSingleStepByteToMessageDecoder"}],"type":"topic","abstract":[{"text":"A simplified version of ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" that can generate zero or one messages for each invocation of ","type":"text"},{"code":"decode","type":"codeVoice"},{"type":"text","text":" or "},{"code":"decodeLast","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Having "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" and "},{"type":"codeVoice","code":"decodeLast"},{"text":" return an optional message avoids re-entrancy problems, since the functions relinquish exclusive access","type":"text"},{"text":" ","type":"text"},{"text":"to the ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" when returning. This allows for greatly simplified processing."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageDecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPDecoder":{"title":"HTTPDecoder","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPDecoder","navigatorTitle":[{"text":"HTTPDecoder","kind":"identifier"}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPDecoder","kind":"identifier"}],"kind":"symbol","type":"topic","url":"\/documentation\/niohttp1\/httpdecoder","abstract":[{"type":"text","text":"A "},{"code":"ChannelInboundHandler","type":"codeVoice"},{"type":"text","text":" that parses HTTP\/1-style messages, converting them from"},{"type":"text","text":" "},{"type":"text","text":"unstructured bytes to a sequence of HTTP messages."}]},"doc://co.pointfree.VaporRouting/documentation/NIOWebSocket/WebSocketFrameDecoder":{"kind":"symbol","role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WebSocketFrameDecoder","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOWebSocket\/WebSocketFrameDecoder","title":"WebSocketFrameDecoder","url":"\/documentation\/niowebsocket\/websocketframedecoder","navigatorTitle":[{"kind":"identifier","text":"WebSocketFrameDecoder"}],"abstract":[{"type":"text","text":"An inbound "},{"code":"ChannelHandler","type":"codeVoice"},{"type":"text","text":" that deserializes websocket frames into a structured"},{"type":"text","text":" "},{"type":"text","text":"format for further processing."}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOJSONRPCFraming/ContentLengthHeaderFrameDecoder":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder","title":"NIOJSONRPCFraming.ContentLengthHeaderFrameDecoder","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ContentLengthHeaderFrameDecoder","kind":"identifier"}],"navigatorTitle":[{"text":"ContentLengthHeaderFrameDecoder","kind":"identifier"}],"type":"topic","role":"symbol","kind":"symbol","url":"\/documentation\/nioextras\/niojsonrpcframing\/contentlengthheaderframedecoder","abstract":[{"type":"codeVoice","code":"ContentLengthHeaderFrameDecoder"},{"type":"text","text":" is responsible for parsing JSON-RPC wire protocol with ‘Content-Length’"},{"type":"text","text":" "},{"type":"text","text":"HTTP-like headers as used by for example by LSP (Language Server Protocol)."}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decodeLast(context:buffer:seenEOF:)-1tkzf":{"kind":"symbol","required":true,"abstract":[{"text":"Decode from a ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" when no more data is incoming and the ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" is about to leave"},{"type":"text","text":" "},{"type":"text","text":"the pipeline."}],"type":"topic","role":"symbol","defaultImplementations":2,"title":"decodeLast(context:buffer:seenEOF:)","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-1tkzf","url":"\/documentation\/niocore\/bytetomessagedecoder\/decodelast(context:buffer:seeneof:)-1tkzf","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"decodeLast","kind":"identifier"},{"text":"(","kind":"text"},{"text":"context","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ChannelHandlerContext","kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC"},{"text":", ","kind":"text"},{"text":"buffer","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"inout","kind":"keyword"},{"text":" ","kind":"text"},{"preciseIdentifier":"s:7NIOCore10ByteBufferV","text":"ByteBuffer","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"seenEOF","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:Sb","text":"Bool","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"preciseIdentifier":"s:7NIOCore13DecodingStateO","text":"DecodingState","kind":"typeIdentifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decode(context:buffer:)":{"title":"decode(context:buffer:)","abstract":[{"text":"Decode from a ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":".","type":"text"}],"required":true,"defaultImplementations":1,"role":"symbol","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decode(context:buffer:)","url":"\/documentation\/niocore\/bytetomessagedecoder\/decode(context:buffer:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"decode"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC"},{"kind":"text","text":", "},{"kind":"externalParam","text":"buffer"},{"kind":"text","text":": "},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"ByteBuffer","preciseIdentifier":"s:7NIOCore10ByteBufferV"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"DecodingState","preciseIdentifier":"s:7NIOCore13DecodingStateO"}],"type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/InboundOut":{"kind":"symbol","url":"\/documentation\/niocore\/bytetomessagedecoder\/inboundout","required":true,"abstract":[{"text":"The type of the messages this ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" decodes to."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/InboundOut","role":"symbol","title":"InboundOut","type":"topic","fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"InboundOut"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decoderRemoved(context:)-sa8l":{"url":"\/documentation\/niocore\/bytetomessagedecoder\/decoderremoved(context:)-sa8l","required":true,"role":"symbol","type":"topic","abstract":[{"text":"Called once this ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" is removed from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"type":"text","text":"."}],"defaultImplementations":1,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderRemoved(context:)-sa8l","title":"decoderRemoved(context:)","kind":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"decoderRemoved"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","text":"ChannelHandlerContext","kind":"typeIdentifier"},{"text":")","kind":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decoderAdded(context:)-7trzq":{"abstract":[{"text":"Called when this ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" is added to the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":".","type":"text"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderAdded(context:)-7trzq","type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"decoderAdded"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC"},{"kind":"text","text":")"}],"defaultImplementations":1,"kind":"symbol","title":"decoderAdded(context:)","url":"\/documentation\/niocore\/bytetomessagedecoder\/decoderadded(context:)-7trzq","required":true},"doc://co.pointfree.VaporRouting/documentation/NIOTLS/SNIHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/SNIHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SNIHandler","kind":"identifier"}],"title":"SNIHandler","url":"\/documentation\/niotls\/snihandler","abstract":[{"type":"text","text":"A channel handler that can be used to arbitrarily edit a channel"},{"type":"text","text":" "},{"type":"text","text":"pipeline based on the hostname requested in the Server Name Indication"},{"type":"text","text":" "},{"type":"text","text":"portion of the TLS Client Hello."}],"kind":"symbol","role":"symbol","navigatorTitle":[{"text":"SNIHandler","kind":"identifier"}],"type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LengthFieldBasedFrameDecoder":{"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder","url":"\/documentation\/nioextras\/lengthfieldbasedframedecoder","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LengthFieldBasedFrameDecoder","kind":"identifier"}],"title":"LengthFieldBasedFrameDecoder","kind":"symbol","abstract":[{"text":"A decoder that splits the received ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" by the number of bytes specified in a fixed length header","type":"text"},{"text":" ","type":"text"},{"text":"contained within the buffer.","type":"text"},{"text":" ","type":"text"},{"text":"For example, if you received the following four fragmented packets:","type":"text"},{"text":" ","type":"text"},{"text":"+—+––+——+––+","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"| A | BC | DEFG | HI |"},{"type":"text","text":" "},{"type":"text","text":"+—+––+——+––+"}],"navigatorTitle":[{"text":"LengthFieldBasedFrameDecoder","kind":"identifier"}],"role":"symbol"}}}