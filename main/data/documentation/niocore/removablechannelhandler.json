{"identifier":{"url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler","interfaceLanguage":"swift"},"metadata":{"externalID":"s:7NIOCore23RemovableChannelHandlerP","roleHeading":"Protocol","modules":[{"name":"NIOCore"}],"role":"symbol","navigatorTitle":[{"text":"RemovableChannelHandler","kind":"identifier"}],"title":"RemovableChannelHandler","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RemovableChannelHandler","kind":"identifier"}],"symbolKind":"protocol"},"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"RemovableChannelHandler"},{"type":"text","text":" is a "},{"type":"codeVoice","code":"ChannelHandler"},{"type":"text","text":" that can be dynamically removed from a "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" whilst"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" is operating normally."},{"type":"text","text":" "},{"type":"text","text":"A "},{"type":"codeVoice","code":"RemovableChannelHandler"},{"type":"text","text":" is required to remove itself from the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" (using"},{"type":"text","text":" "},{"type":"codeVoice","code":"ChannelHandlerContext.removeHandler"},{"type":"text","text":") as soon as possible."}],"relationshipsSections":[{"kind":"relationships","title":"Inherits From","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler"],"type":"inheritsFrom"},{"kind":"relationships","title":"Conforming Types","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AcceptBackoffHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/ApplicationProtocolNegotiationHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/BackPressureHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPRequestEncoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/HTTPResponseCompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPResponseEncoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerPipelineHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerProtocolErrorHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerUpgradeHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IdleStateHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientResponseAggregator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientUpgradeHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestCompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestDecompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPResponseDecompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPServerRequestAggregator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLClientHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLServerHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOWritePCAPHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSClientHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSServerHandshakeHandler"],"type":"conformingTypes"}],"sections":[],"schemaVersion":{"minor":3,"major":0,"patch":0},"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"]]},"topicSections":[{"title":"Instance Methods","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler\/removeHandler(context:removalToken:)-2jaoc"]}],"kind":"symbol","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/niocore\/removablechannelhandler"]}],"primaryContentSections":[{"declarations":[{"tokens":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RemovableChannelHandler","kind":"identifier"},{"text":" : ","kind":"text"},{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler","text":"ChannelHandler","kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore14ChannelHandlerP"}],"platforms":["Linux"],"languages":["swift"]}],"kind":"declarations"},{"kind":"content","content":[{"level":2,"type":"heading","text":"Overview","anchor":"overview"},{"content":[{"type":"paragraph","inlineContent":[{"text":"When a ","type":"text"},{"type":"codeVoice","code":"Channel"},{"text":" gets torn down, every ","type":"text"},{"type":"codeVoice","code":"ChannelHandler"},{"text":" in the ","type":"text"},{"type":"codeVoice","code":"Channel"},{"text":"’s ","type":"text"},{"type":"codeVoice","code":"ChannelPipeline"},{"text":" will be","type":"text"},{"text":" ","type":"text"},{"text":"removed from the ","type":"text"},{"type":"codeVoice","code":"ChannelPipeline"},{"text":". Those removals however happen synchronously and are not going through","type":"text"},{"text":" ","type":"text"},{"text":"the methods of this protocol.","type":"text"}]}],"type":"aside","style":"note"}]}],"references":{"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPServerProtocolErrorHandler":{"url":"\/documentation\/niohttp1\/httpserverprotocolerrorhandler","abstract":[{"type":"text","text":"A simple channel handler that catches errors emitted by parsing HTTP requests"},{"type":"text","text":" "},{"type":"text","text":"and sends 400 Bad Request responses."}],"role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPServerProtocolErrorHandler","kind":"identifier"}],"navigatorTitle":[{"text":"HTTPServerProtocolErrorHandler","kind":"identifier"}],"kind":"symbol","title":"HTTPServerProtocolErrorHandler","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerProtocolErrorHandler","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageHandler":{"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageHandler","navigatorTitle":[{"text":"ByteToMessageHandler","kind":"identifier"}],"kind":"symbol","abstract":[{"type":"text","text":"A handler which turns a given "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" into a "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":" that can then be added to a"},{"type":"text","text":" "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":"."}],"type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"ByteToMessageHandler","kind":"identifier"}],"url":"\/documentation\/niocore\/bytetomessagehandler","title":"ByteToMessageHandler","conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"type":"codeVoice","code":"Decoder"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"."}]}},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPServerPipelineHandler":{"title":"HTTPServerPipelineHandler","role":"symbol","kind":"symbol","type":"topic","url":"\/documentation\/niohttp1\/httpserverpipelinehandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPServerPipelineHandler","kind":"identifier"}],"navigatorTitle":[{"text":"HTTPServerPipelineHandler","kind":"identifier"}],"abstract":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"ChannelHandler"},{"text":" that handles HTTP pipelining by buffering inbound data until a","type":"text"},{"text":" ","type":"text"},{"text":"response has been sent.","type":"text"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerPipelineHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOWritePCAPHandler":{"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelHandler"},{"type":"text","text":" that can write a "},{"type":"reference","identifier":"https:\/\/en.wikipedia.org\/wiki\/Pcap","isActive":true},{"type":"text","text":" containing the send\/received"},{"type":"text","text":" "},{"type":"text","text":"data as synthesized TCP packet captures."}],"role":"symbol","kind":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOWritePCAPHandler"}],"navigatorTitle":[{"kind":"identifier","text":"NIOWritePCAPHandler"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOWritePCAPHandler","url":"\/documentation\/nioextras\/niowritepcaphandler","title":"NIOWritePCAPHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLHandler","role":"symbol","url":"\/documentation\/niossl\/niosslhandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSSLHandler"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOSSLHandler"}],"title":"NIOSSLHandler","abstract":[{"text":"The base class for all NIOSSL handlers. This class cannot actually be instantiated by","type":"text"},{"type":"text","text":" "},{"type":"text","text":"users directly: instead, users must select which mode they would like their handler to"},{"type":"text","text":" "},{"type":"text","text":"operate in, client or server."}],"type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLClientHandler":{"navigatorTitle":[{"text":"NIOSSLClientHandler","kind":"identifier"}],"url":"\/documentation\/niossl\/niosslclienthandler","abstract":[{"text":"A channel handler that wraps a channel in TLS using NIOSSL.","type":"text"},{"text":" ","type":"text"},{"text":"This handler can be used in channels that are acting as the client","type":"text"},{"text":" ","type":"text"},{"text":"in the TLS dialog. For server connections, use the ","type":"text"},{"type":"codeVoice","code":"NIOSSLServerHandler"},{"text":".","type":"text"}],"title":"NIOSSLClientHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOSSLClientHandler","kind":"identifier"}],"role":"symbol","kind":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLClientHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelHandler":{"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ChannelHandler","kind":"identifier"}],"type":"topic","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler","role":"symbol","abstract":[{"text":"You should ","type":"text"},{"inlineContent":[{"text":"never","type":"text"}],"type":"emphasis"},{"text":" implement this protocol directly. Please implement one of its sub-protocols.","type":"text"}],"title":"ChannelHandler","navigatorTitle":[{"kind":"identifier","text":"ChannelHandler"}],"url":"\/documentation\/niocore\/channelhandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPServerUpgradeHandler":{"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerUpgradeHandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPServerUpgradeHandler"}],"url":"\/documentation\/niohttp1\/httpserverupgradehandler","abstract":[{"text":"A server-side channel handler that receives HTTP requests and optionally performs a HTTP-upgrade.","type":"text"},{"text":" ","type":"text"},{"text":"Removes itself from the channel pipeline after the first inbound request on the connection, regardless of","type":"text"},{"text":" ","type":"text"},{"text":"whether the upgrade succeeded or not.","type":"text"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"HTTPServerUpgradeHandler"}],"title":"HTTPServerUpgradeHandler","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/AcceptBackoffHandler":{"navigatorTitle":[{"kind":"identifier","text":"AcceptBackoffHandler"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AcceptBackoffHandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"AcceptBackoffHandler"}],"url":"\/documentation\/niocore\/acceptbackoffhandler","role":"symbol","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelHandler"},{"type":"text","text":" that implements a backoff for a "},{"type":"codeVoice","code":"ServerChannel"},{"type":"text","text":" when accept produces an "},{"type":"codeVoice","code":"IOError"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"These errors are often recoverable by reducing the rate at which we call accept."}],"kind":"symbol","title":"AcceptBackoffHandler","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPResponseEncoder":{"abstract":[{"text":"A ","type":"text"},{"code":"ChannelOutboundHandler","type":"codeVoice"},{"text":" that can serialize HTTP responses.","type":"text"}],"title":"HTTPResponseEncoder","url":"\/documentation\/niohttp1\/httpresponseencoder","fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPResponseEncoder"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPResponseEncoder","kind":"symbol","role":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"HTTPResponseEncoder"}]},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLServerHandler":{"type":"topic","kind":"symbol","abstract":[{"type":"text","text":"A channel handler that wraps a channel in TLS using NIOSSL. This"},{"type":"text","text":" "},{"type":"text","text":"handler can be used in channels that are acting as the server in"},{"type":"text","text":" "},{"type":"text","text":"the TLS dialog. For client connections, use the "},{"type":"codeVoice","code":"NIOSSLClientHandler"},{"type":"text","text":"."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLServerHandler","navigatorTitle":[{"kind":"identifier","text":"NIOSSLServerHandler"}],"title":"NIOSSLServerHandler","url":"\/documentation\/niossl\/niosslserverhandler","role":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSSLServerHandler"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPClientResponseAggregator":{"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientResponseAggregator","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOHTTPClientResponseAggregator","kind":"identifier"}],"abstract":[{"text":"A ","type":"text"},{"code":"ChannelInboundHandler","type":"codeVoice"},{"text":" that handles HTTP chunked ","type":"text"},{"code":"HTTPClientResponsePart","type":"codeVoice"},{"text":" ","type":"text"},{"text":"messages by aggregating individual message chunks into a single","type":"text"},{"text":" ","type":"text"},{"code":"NIOHTTPClientResponseFull","type":"codeVoice"},{"text":".","type":"text"}],"url":"\/documentation\/niohttp1\/niohttpclientresponseaggregator","navigatorTitle":[{"text":"NIOHTTPClientResponseAggregator","kind":"identifier"}],"role":"symbol","title":"NIOHTTPClientResponseAggregator","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPClientUpgradeHandler":{"url":"\/documentation\/niohttp1\/niohttpclientupgradehandler","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientUpgradeHandler","navigatorTitle":[{"text":"NIOHTTPClientUpgradeHandler","kind":"identifier"}],"kind":"symbol","role":"symbol","abstract":[{"text":"A client-side channel handler that sends a HTTP upgrade handshake request to perform a HTTP-upgrade.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"When the first HTTP request is sent, this handler will add all appropriate headers to perform an upgrade to"},{"type":"text","text":" "},{"type":"text","text":"the a protocol. It may add headers for a set of protocols in preference order."},{"type":"text","text":" "},{"type":"text","text":"If the upgrade fails (i.e. response is not 101 Switching Protocols), this handler simply"},{"type":"text","text":" "},{"type":"text","text":"removes itself from the pipeline. If the upgrade is successful, it upgrades the pipeline to the new protocol."}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOHTTPClientUpgradeHandler","kind":"identifier"}],"title":"NIOHTTPClientUpgradeHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/NIOHTTPRequestDecompressor":{"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPRequestDecompressor"}],"url":"\/documentation\/niohttpcompression\/niohttprequestdecompressor","title":"NIOHTTPRequestDecompressor","abstract":[],"navigatorTitle":[{"kind":"identifier","text":"NIOHTTPRequestDecompressor"}],"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestDecompressor","kind":"symbol","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/BackPressureHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/BackPressureHandler","title":"BackPressureHandler","role":"symbol","url":"\/documentation\/niocore\/backpressurehandler","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"BackPressureHandler"}],"type":"topic","abstract":[{"type":"text","text":"ChannelHandler implementation which enforces back-pressure by stopping to read from the remote peer when it cannot write back fast enough."},{"type":"text","text":" "},{"type":"text","text":"It will start reading again once pending data was written."}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"BackPressureHandler"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPRequestEncoder":{"kind":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPRequestEncoder","kind":"identifier"}],"type":"topic","role":"symbol","navigatorTitle":[{"text":"HTTPRequestEncoder","kind":"identifier"}],"title":"HTTPRequestEncoder","url":"\/documentation\/niohttp1\/httprequestencoder","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPRequestEncoder","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelOutboundHandler"},{"text":" that can serialize HTTP requests.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOSOCKS/SOCKSServerHandshakeHandler":{"navigatorTitle":[{"kind":"identifier","text":"SOCKSServerHandshakeHandler"}],"fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"SOCKSServerHandshakeHandler"}],"type":"topic","abstract":[{"text":"Add this handshake handler to the front of your channel, closest to the network.","type":"text"},{"text":" ","type":"text"},{"text":"The handler will receive bytes from the network and run them through a state machine","type":"text"},{"text":" ","type":"text"},{"text":"and parser to enforce SOCKSv5 protocol correctness. Inbound bytes will by parsed into","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"ClientMessage"},{"text":" for downstream consumption. Send ","type":"text"},{"type":"codeVoice","code":"ServerMessage"},{"text":" to this","type":"text"},{"text":" ","type":"text"},{"text":"handler.","type":"text"}],"role":"symbol","url":"\/documentation\/niosocks\/socksserverhandshakehandler","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSServerHandshakeHandler","kind":"symbol","title":"SOCKSServerHandshakeHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOTLS/ApplicationProtocolNegotiationHandler":{"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/ApplicationProtocolNegotiationHandler","url":"\/documentation\/niotls\/applicationprotocolnegotiationhandler","navigatorTitle":[{"kind":"identifier","text":"ApplicationProtocolNegotiationHandler"}],"abstract":[{"type":"text","text":"A helper "},{"code":"ChannelInboundHandler","type":"codeVoice"},{"type":"text","text":" that makes it easy to swap channel pipelines"},{"type":"text","text":" "},{"type":"text","text":"based on the result of an ALPN negotiation."}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ApplicationProtocolNegotiationHandler"}],"title":"ApplicationProtocolNegotiationHandler","role":"symbol","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/NIOHTTPRequestCompressor":{"abstract":[{"text":"NIOHTTPResponseCompressor is an outbound channel handler that handles automatic streaming compression of","type":"text"},{"text":" ","type":"text"},{"text":"HTTP requests.","type":"text"}],"type":"topic","navigatorTitle":[{"kind":"identifier","text":"NIOHTTPRequestCompressor"}],"title":"NIOHTTPRequestCompressor","url":"\/documentation\/niohttpcompression\/niohttprequestcompressor","role":"symbol","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestCompressor","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPRequestCompressor"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RemovableChannelHandler/removeHandler(context:removalToken:)-2jaoc":{"type":"topic","url":"\/documentation\/niocore\/removablechannelhandler\/removehandler(context:removaltoken:)-2jaoc","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler\/removeHandler(context:removalToken:)-2jaoc","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"removeHandler","kind":"identifier"},{"text":"(","kind":"text"},{"text":"context","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"removalToken","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"RemovalToken","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC12RemovalTokenV","kind":"typeIdentifier"},{"text":")","kind":"text"}],"title":"removeHandler(context:removalToken:)","defaultImplementations":1,"kind":"symbol","abstract":[{"text":"Ask the receiving ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" to remove itself from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" as soon as possible.","type":"text"},{"text":" ","type":"text"},{"text":"The receiving ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" may elect to remove itself sometime after this method call, rather than","type":"text"},{"text":" ","type":"text"},{"text":"immediately, but if it does so it must take the necessary precautions to handle events arriving between the","type":"text"},{"text":" ","type":"text"},{"text":"invocation of this method and the call to ","type":"text"},{"type":"codeVoice","code":"ChannelHandlerContext.removeHandler"},{"text":" that triggers the actual","type":"text"},{"text":" ","type":"text"},{"text":"removal.","type":"text"}],"required":true},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"kind":"symbol","url":"\/documentation\/niocore","title":"NIOCore","role":"collection","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","abstract":[]},"doc://co.pointfree.VaporRouting/documentation/NIOSOCKS/SOCKSClientHandler":{"type":"topic","abstract":[{"type":"text","text":"Connects to a SOCKS server to establish a proxied connection"},{"type":"text","text":" "},{"type":"text","text":"to a host. This handler should be inserted at the beginning of a"},{"type":"text","text":" "},{"type":"text","text":"channel’s pipeline. Note that SOCKS only supports fully-qualified"},{"type":"text","text":" "},{"type":"text","text":"domain names and IPv4 or IPv6 sockets, and not UNIX sockets."}],"role":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"SOCKSClientHandler","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSClientHandler","navigatorTitle":[{"text":"SOCKSClientHandler","kind":"identifier"}],"kind":"symbol","title":"SOCKSClientHandler","url":"\/documentation\/niosocks\/socksclienthandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/NIOHTTPResponseDecompressor":{"url":"\/documentation\/niohttpcompression\/niohttpresponsedecompressor","navigatorTitle":[{"kind":"identifier","text":"NIOHTTPResponseDecompressor"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPResponseDecompressor"}],"kind":"symbol","role":"symbol","title":"NIOHTTPResponseDecompressor","abstract":[],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPResponseDecompressor","type":"topic"},"https://en.wikipedia.org/wiki/Pcap":{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Pcap","url":"https:\/\/en.wikipedia.org\/wiki\/Pcap","title":".pcap file","titleInlineContent":[{"type":"codeVoice","code":".pcap"},{"type":"text","text":" file"}],"type":"link"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/IdleStateHandler":{"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"IdleStateHandler"}],"type":"topic","abstract":[{"type":"text","text":"Triggers an IdleStateEvent when a Channel has not performed read, write, or both operation for a while."}],"url":"\/documentation\/niocore\/idlestatehandler","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IdleStateHandler","title":"IdleStateHandler","navigatorTitle":[{"kind":"identifier","text":"IdleStateHandler"}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RemovableChannelHandler":{"title":"RemovableChannelHandler","navigatorTitle":[{"kind":"identifier","text":"RemovableChannelHandler"}],"role":"symbol","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"RemovableChannelHandler"},{"type":"text","text":" is a "},{"type":"codeVoice","code":"ChannelHandler"},{"type":"text","text":" that can be dynamically removed from a "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" whilst"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" is operating normally."},{"type":"text","text":" "},{"type":"text","text":"A "},{"type":"codeVoice","code":"RemovableChannelHandler"},{"type":"text","text":" is required to remove itself from the "},{"code":"ChannelPipeline","type":"codeVoice"},{"type":"text","text":" (using"},{"type":"text","text":" "},{"code":"ChannelHandlerContext.removeHandler","type":"codeVoice"},{"type":"text","text":") as soon as possible."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler","type":"topic","kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"RemovableChannelHandler"}],"url":"\/documentation\/niocore\/removablechannelhandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPServerRequestAggregator":{"url":"\/documentation\/niohttp1\/niohttpserverrequestaggregator","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"text":" that handles HTTP chunked ","type":"text"},{"type":"codeVoice","code":"HTTPServerRequestPart"},{"text":" ","type":"text"},{"text":"messages by aggregating individual message chunks into a single","type":"text"},{"text":" ","type":"text"},{"code":"NIOHTTPServerRequestFull","type":"codeVoice"},{"type":"text","text":"."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPServerRequestAggregator","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPServerRequestAggregator"}],"title":"NIOHTTPServerRequestAggregator","kind":"symbol","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOHTTPServerRequestAggregator"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/HTTPResponseCompressor":{"kind":"symbol","role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPResponseCompressor","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/HTTPResponseCompressor","title":"HTTPResponseCompressor","url":"\/documentation\/niohttpcompression\/httpresponsecompressor","navigatorTitle":[{"text":"HTTPResponseCompressor","kind":"identifier"}],"abstract":[{"text":"A HTTPResponseCompressor is a duplex channel handler that handles automatic streaming compression of","type":"text"},{"text":" ","type":"text"},{"text":"HTTP responses. It respects the client’s Accept-Encoding preferences, including q-values if present,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and ensures that clients are served the compression algorithm that works best for them."}]}}}